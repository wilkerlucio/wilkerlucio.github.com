---
layout: post
title: Porque usar UTF-8 - Codificando/Decodificando
published: true
---
<p>Bom galera, como prometido venho hoje aqui demonstrar como o UTF-8 realmente funciona por debaixo dos panos, e vamos criar uma implementa&ccedil;&atilde;o do mesmo utilizando JavaScript.<p />Como eu j&aacute; havia dito antes, o UTF-8 usa uma codifica&ccedil;&atilde;o de tamanho vari&aacute;vel, onde cada caractere pode ocupar entre 1 e 4 bytes, para que isso seja poss&iacute;vel, existem bits que s&atilde;o usados para verificar isso, vamos ver o primeiro caso:<p />Eu falei para voc&ecirc;s anteriormente que para os valores ASCII padr&atilde;o o UTF-8 mant&eacute;m a compatibilidade, ou seja, n&atilde;o existe nenhum transforma&ccedil;&atilde;o para os caracteres entre 0 e 127, se voc&ecirc; olhar o bin&aacute;rio disso, vai perceber que isso varia entre:<br /><code>00000000<br />01111111<br /></code><br />&Eacute; importante notar que o primeiro bit do byte n&atilde;o &eacute; modificado, isso &eacute; importante porque ele &eacute; <span style="font-weight: bold;">flag</span> que indica se vamos precisar de mais bytes no caractere, ent&atilde;o, a partir do valor 128 temos que utilizar algum tipo de transforma&ccedil;&atilde;o.<p />Antes de proseguirmos com os detalhes vamos iniciar nosso script, comecem ele da seguinte forma:</p>
<script src="https://gist.github.com/748680.js?file=utf8_demo.html"></script>
<p><br />Esse &eacute; um simples script que por hora n&atilde;o faz nada :P<p />Mas ele pega o valor do campo de cima e mostra esse valor codificado no campo de baixo, assim como pega o campo de baixo e joga decoficidado no campo de cima. A partir de agora s&oacute; iremos trabalhar nos m&eacute;todos <span style="font-weight: bold;">encode</span> e <span style="font-weight: bold;">decode</span> do objeto <span style="font-weight: bold;">UTF8</span> que criamos acima.<p />Voltando ao UTF-8, vamos criar primeiro o codificador, ent&atilde;o vamos continuar o entendimento dos bytes.<p />A partir do momento que o primeiro bit deveria ser usado, ent&atilde;o a coisa muda, imaginando um caso simples, o caractere de numero 128, se continuassemos usando a maneira simples de somar bits teriamos a seguinte sequencia de bits:<br /><code>10000000</code><br />Mas para o UTF-8 a sequencia correta seria:<br /><code>11000010 10000000</code><br />Parece complicado, mas n&atilde;o &eacute; para tanto, quando passamos dos 128 caracteres iniciais temos alguns "moldes" onde devemos encaixar nossos bits, que no caso s&atilde;o os seguintes (por uso de bytes):<br /><code>1 byte  - 0xxxxxxx<br />2 bytes - 110xxxxx 10xxxxxx<br />3 bytes - 1110xxxx 10xxxxxx 10xxxxxx<br />4 bytes - 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx<br /></code><br />Esses moldes n&atilde;o s&atilde;o ao acaso, e como pode-se ver eles seguem um padr&atilde;o, esses moldes s&atilde;o importantes para que o precesso de decodifica&ccedil;&atilde;o, notem que a partir dos primeiros bits do primeiro byte &eacute; possivel saber exatamente quantos bytes tem o caractere atual.<p />Para criamos o processo de encoding, o primeiro passo &eacute; descobrir quantos bytes ser&atilde;o nescess&aacute;rios para criar nosso caractere no formato UTF-8, para saber isso &eacute; s&oacute; contar os limites a partir do n&uacute;mero de bits que podem ser alocados em cada n&iacute;vel. Mas como eu sou muito legal eu j&aacute; vou disponibilar esses n&uacute;meros para voc&ecirc;, e s&atilde;o eles: 128, 2048, 65536<p />Pra quem nunca executou opera&ccedil;&otilde;es bit a bit pode parecer um pouco complicado sair mexendo eles por ai, mas &eacute; facil, primeiro mantenha a calculadora do windows aberta (em modo cient&iacute;fico, assim voc&ecirc; pode converter entre decimal, hexadecimal e binario sempre que precisar, e voc&ecirc; vai precisar), ent&atilde;o vamos criar a fun&ccedil;&atilde;o de encode:</p>
<script src="https://gist.github.com/748680.js?file=encoder.js"></script>
<p><br />Pra quem n&atilde;o est&aacute; acostumado com manipula&ccedil;&atilde;o de bits isso pode parecer coisa de louco, mas &eacute; simples, vou ilustrar como funcionam os operadores bit a bit utilizados nas opera&ccedil;&otilde;es:<p />right shift (&gt;&gt;): esse operador simplesmente move bits a direita, caso o bit ultrapasse o primeiro ele &eacute; descartado, exemplos:<br /><code>00011000 &gt;&gt; 2<br />resulta em: 00000110<br />01101110 &gt;&gt; 3<br />resulta em: 00001101<br /></code><br />ou seja, eh simplesmente mover bits a direita (se lembre, tudo isso &eacute; forma de representa&ccedil;&atilde;o, tudo s&atilde;o bits, desde numeros a caracteres, vc n&atilde;o vai digitar em formato bin&aacute;rio nunca, pelo menos n&atilde;o em javascript)<p />E bin&aacute;rio (&amp;): executa uma opera&ccedil;&atilde;o E entre bin&aacute;rios, a id&eacute;ia &eacute; simples, voc&ecirc; coloca os bits que s&atilde;o comparados em uma listagem de 1 para 1, caso o valor seja 1 nos 2, o result&aacute;do ser&aacute; 1, caso contr&aacute;rio ser&aacute; 0, exemplos:<br /><code>&nbsp;&nbsp;00110111<br />&amp; 01100010<br />----------<br />&nbsp;&nbsp;00100010<br /><br />&nbsp;&nbsp;01111000<br />&amp; 00111110<br />----------<br />&nbsp;&nbsp;00111000<br /></code><br />esse operador &eacute; muito usado para mascarar bits, por exemplo, voc&ecirc; quer apenas os 4 &uacute;ltimos bits de um dado bin&aacute;rio, ent&atilde;o voc&ecirc; opera um E contendo 00001111 sobre esse bin&aacute;rio, dessa forma voc&ecirc; ter&aacute; o resultado com os 4 &uacute;ltimos valores.<p />OU bin&aacute;rio (|): esse &eacute; parecido com o anterior, mas com uma diferen&ccedil;a b&aacute;sica, esse retorn 1 exceto se os 2 operadores forem 0, exemplo:<br /><code>&nbsp;&nbsp;00110101<br />| 11100001<br />----------<br />&nbsp;&nbsp;11110101<br /></code><br />Isso s&atilde;o alguns operadores bin&aacute;rios, caso n&atilde;o tenha ficado muito claro podem tirar suas d&uacute;vidas comigo por coment&aacute;rios ou e-mail.<p />Dever de casa: pegue os n&uacute;meros utilizados no algoritmo anterior em formato hexadecimal (que comecam com 0x) e veja suas formas em bin&aacute;rio (use a calculadora do windows ou similar), e va executando o algoritmo como se fosse o computador, dessa forma voc&ecirc; ter&aacute; um melhor entendimento do algoritmo.<p />O encode est&aacute; pronto, agora precisamos pegar os c&oacute;digos Unicode a partir disso que geramos, ent&atilde;o vamos criar o decode:</p>
<script src="https://gist.github.com/748680.js?file=decoder.js"></script>
<p><p />O processo inverso &eacute; exatamente a mesma coisa, &eacute; s&oacute; pegar os bits que voc&ecirc; jogou no formato e junta-los novamente. Para descobrir quantos bytes s&atilde;o usados eu utilizei a seguinte id&eacute;ia:<p />1 - se for menor que 128, ent&atilde;o &eacute; padr&atilde;o ASCII, jogar direto<br />2 - verificar bit zero dentro do primeiro byte, a partir disso &eacute; poss&iacute;vel descobrir o n&uacute;mero (se baseando nos formatos poss&iacute;veis).<p />O &uacute;nico operador novo &eacute; o <span style="font-weight: bold;">left shift (&lt;&lt;)</span> que simplesmente move os bits para esquerda ;)<p />Bom galera, termino por aqui, qualquer d&uacute;vida entrem em contato comigo por e-mail ou coment&aacute;rios.<p />Mudarei de assunto no pr&oacute;ximo post (assunto indefinido at&eacute; o momento ;).<p />See yah!</p>
<div class="blogger-post-footer"><img class="posterous_download_image" src="https://blogger.googleusercontent.com/tracker/1053117534982092858-6846504573157449901?l=wilker-dev.blogspot.com" height="1" alt="" width="1" /></div>
<p>Voc&ecirc; pode conferir abaixo o resultado final:  <iframe src="http://jsfiddle.net/wilkerlucio/Kj3NA/embedded/"></iframe></p>
