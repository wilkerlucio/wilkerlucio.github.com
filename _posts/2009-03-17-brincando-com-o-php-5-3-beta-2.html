---
layout: post
title: Brincando com o PHP 5.3 beta 2
published: true
---
Bom, pensando um pouco sobre a arquitetura da Framework que eu pretendo criar, eu decidi dar uma pesquisada sobre as novas versões do PHP para ver oque vem por ai. Fiquei feliz em saber que o PHP 5.3 deve ter um release oficial dentro dos próximos 3 mêses.<p />Como minha Framework deve demorar muito mais que isso para ter um release oficial, então eu resolvi instalar o PHP 5.3 Beta aqui na minha máquina para ver como está ficando. Para quem quizer instalar, eu encontrei um <a href="http://forge.typo3.org/wiki/45/PHP_53alpha_installation_on_Windows_%28xampp%29">tutorial muito legal</a> de como instalar ele na porta 81 a partir de uma instalação XAMPP padrão (não se preocupe, ele é igualmente útil mesmo que você não utilize o XAMPP).<p />Depois de instalado, vamos aos testes :)<p /><h3>Late Static Binding</h3><br />Esse é um recurso que já me fez perder bastante a paciência (na verdade a ausência dele...). O problema do que o Late Static Binding resolve é mais fácil de ser descrito com exemplos, então vamos a um exemplo:<p /><div class="CodeRay">
  <div class="code"><pre>class A{  public static function metodo()  {    return self::outro_metodo();  }  public static function outro_metodo()  {    return &quot;classe A chamando&quot;;  }}class B{  public static function outro_metodo()  {    return &quot;classe B sobreescreveu&quot;;  }}echo B::metodo();</pre></div>
</div>
<p />Dado o código acima, o natural (na minha opinião) seria que a saída fosse: "classe B sobreescreveu"<p />Mas esse não é o comportamento que o PHP adota, para esse caso o retorno seria: "classe A chamando"<p />Isso ocorre pelo local da chamada no PHP, ele sabe que o método "metodo" foi definido na classe A, então mesmo chamando a partir de B, ele vai ser executado como um membro de A.<p />Isso pode gerar grandes problemas quando se quer fazer com métodos estáticos com um certo nível de complexidade, no meu caso a classe do ActiveRecord.<p />Com o Late Static Binding esse problema é resolvido da seguinte forma:<p /><div class="CodeRay">
  <div class="code"><pre>class A{  public static function metodo()  {    return static::outro_metodo();  }  public static function outro_metodo()  {    return &quot;classe A chamando&quot;;  }}class B{  public static function outro_metodo()  {    return &quot;classe B sobreescreveu&quot;;  }}echo B::metodo();</pre></div>
</div>
<p />O código está quase totalmente igual, a diferença é na hora da chamada do "outro_metodo" que antes era "self::outro_metodo()" e agora é "static::outro_metodo()". Com isso o PHP consegue manter a compatibilidade com códigos antigos.<p />Essa é uma grande adição e vai fazer com que possamos criar classes como o ActiveRecord com uma interface mais limpa :)<p />So pra finalizar, uma dica que também veio junto com esse recurso, que é o novo método: get_called_class()<p />esse método retorna a classe atual usando o mesmo esquema do static no exemplo anterior.<p /><h3>Namespaces</h3><br />Esse aqui, não sei como o PHP passou tanto tempo sem ter... De qualquer forma, para os "Javistas" agora temos pacotes, para "Rubistas" temos módulos, e por ai vai.<p />Os namespaces não são nada além de uma forma para organizar suas classes (e como consequência, ajudando a evitar conflito de nomes).<p />A verdade é que não fiquei muito satisfeito como o PHP está usando isso no momento (pode mudar, espero que mudem...).<p />Vou citar alguns pontos, a começar pela definição/uso:<p />namespace MeuNamespace\SubNamespace\Aninhando;<p />sinceramente... quem foi que teve a idéia de usar a barra invertida para separar os namespaces? achei feio... mas dos males esse é o menor (para o uso as barras são usadas da mesma forma)<p />Quem conhece Java/.NET (ou outros, vocês entenderam...), sabe que ao importarmos um pacote, as classes ficam diretamente acessiveis; o PHP comeca falhando nesse ponto... não é possível importar um pacote e ter as classes diretamente acessiveis... se você quizer ter acesso direto a classe (como se ela estivesse no pacote atual) você deve importar as classes uma a uma, exemplo:<p /><div class="CodeRay">
  <div class="code"><pre>use MeuNamespace\A;use MeuNamespace\B;$a = new A();$b = new B();</pre></div>
</div>
<p />tendo em mente o mesmo caso, o código abaixo NÃO funciona:<p /><div class="CodeRay">
  <div class="code"><pre>use MeuNamespace;$a = new A();$b = new B();</pre></div>
</div>
<p />Além de receber um erro de ClassNotFound você ainda ganha de presente um Warning: The use statement with non-compound name 'MeuNamespace' has no effect<p />Para resumir um pouco o resto dos recursos de use (para importar) vou citar alguns exemplos (esses funcionam):<p /><div class="CodeRay">
  <div class="code"><pre>use MeuNamespace\SubNamespace;use MeuNamespace as MN;$a = new MN\A();$b = new MN\B();$c = SubNamespace\C();</pre></div>
</div>
<p />Outra coisa que imcomoda é quando se está desenvolvendo dentro de um namespace... Entendam que o PHP considera os namespaces como pastas do seu HD, então, se você estiver trabalhando em um namespace, e precisar acessar o namespace global, você precisa avisar isso, exemplo:<p /><div class="CodeRay">
  <div class="code"><pre>namespace MeuNamespace; //informa o namespace do arquivoclass A{  public function __construct($a)  {    $a = \trim($a);  }}</pre></div>
</div>
<p />Ou seja, nada limpo pra se programar... espero que a turma do PHP também ache isso... senão vamos ter códigos PHP entupidos com essas barras invertidas no meio...<p /><a href="http://wiki.php.net/rfc/namespaceseparator">RFC: Namespace Separator</a><br /><a href="http://wiki.php.net/rfc/namespaceresolution">RFC: Namespace Resolution</a><p /><h3>Traits</h3><br />Os traits no PHP, vamos resumir isso de forma simples, sabe aquelas interfaces que você implementa no objeto, você diz que o objeto vai usar a interface, e então você cria a implementação para os respectivos métodos. Os traits são como interfaces, mas com uma grande diferença: eles vem com implementação.<p />Isso resolve o problema de herança múltipla, para quem é do mundo Ruby, os Traits são os Mixins do PHP :P<p />Isso é legal para várias coisas, quem programa em Ruby sabe o poder que podemos ter com isso (falo da turma do Ruby porque para eles isso já é muito comum), um exemplo simples seria para quebrar a implementação de uma classe em várias partes (pretendo usar isso no ActiveRecord visto o tamanho da mesma...).<p />Eu achei estranho pois não consegui utilizar os traits, embora no RFC do PHP esteja dizendo que eles foram inclusos no PHP 5.3, quem sabe no proximo beta release?<p /><a href="http://wiki.php.net/rfc/traits">RFC: Traits</a><p /><h3>Lambda e Closures</h3><br />Com certeza esse é um dos recursos mais esperados por mim. Com isso será possível executar uma programação de high-order no PHP.<p />Nas versões atuais já é possível algo semelhante utilizando o método <a href="http://br.php.net/manual/pt_BR/function.create-function.php">create_function()</a> do PHP, mas além de acabar com a organização do código, não suporte sintaxe highlight, ainda é algo bastante limitado.<p />Agora com funções lambda e closures é bem mais prático criar uma programação high-order utilizando funções como blocos.<p />Eu fiz alguns testes aqui para uma criação de enumeraveis como em Javascript e Ruby:<p /><div class="CodeRay">
  <div class="code"><pre>class ArrayData implements IteratorAggregate{  private $data;    public function __construct($data = array())  {    $this-&gt;data = $data;  }    public function getIterator()  {    return new ArrayIterator($this-&gt;data);  }    public function push()  {    $args = func_get_args();        foreach ($args as $arg) {      array_push($this-&gt;data, $arg);    }  }    public function each($block)  {    foreach ($this as $value) {      $block($value);    }  }    public function map($block)  {    return new static(array_map($block, $this-&gt;data));  }    public function inject($base, $block)  {    $this-&gt;each(function($value) use (&amp;$base, $block) {      $base = $block($base, $value);    });        return $base;  }    public function reject($block)  {    $new_data = new static;        $this-&gt;each(function($value) use ($block, $new_data) {      if (!$block($value)) $new_data-&gt;push($value);    });        return $new_data;  }}</pre></div>
</div>
<p />Esse foi apenas um exemplo básico para fins de teste, com o código acima foi possível criar algo assim:<p /><div class="CodeRay">
  <div class="code"><pre>$data = new ArrayData(array(1, 2, 3));$data-&gt;push(4, 5);$data-&gt;map(function($value) {  return $value * 2;})-&gt;reject(function($value) {  return $value &gt; 5;})-&gt;each(function($value) {  echo &quot;$value &quot;;});echo $data-&gt;inject(0, function($sum, $value) {  return $sum + $value;});</pre></div>
</div>
<p />Apesar de bastante legal, a performance não foi essas coisas, fiz o seguinte teste de beenchmark:<p /><div class="CodeRay">
  <div class="code"><pre>function beenchmark($block){  $start = microtime(true);  $block();  echo &quot;Executed in &quot; . (microtime(true) - $start);}$a = range(0, 100000);$b = new ArrayData($a);beenchmark(function() use ($a) {  $s = 0;    foreach ($a as $value) {    $s += $value;  }});beenchmark(function() use ($b) {  $s = 0;    $b-&gt;each(function($value) use (&amp;$s) {    $s += $value;  });});beenchmark(function() use ($b) {  $b-&gt;inject(0, function($s, $value) {    return $s + $value;  });});</pre></div>
</div>
<p />Que resultou respectivamente em:<p /><code>Executed in 0.0579040050507<br />Executed in 0.131916046143<br />Executed in 0.254753112793<br /></code><br />Como pode-se ver, uma operação de inject teve um desempenho 5 vezes pior que uma versão linear simples com arrays.<p />Obviamente a classe pode ter algumas coisas mais "raw" na implementação para melhorar esse cenário, estou apenas demostrando oque acontece no caso de uso excessivo de lambda, então devemos utilizar com cautela.<p />Fiz um teste onde o resultado saiu em desacordo com o RFC do PHP, usando o seguinte código:<p /><div class="CodeRay">
  <div class="code"><pre>class A{  public function my_method()  {    return &quot;ok, reach here&quot;;  }    public function inner_lambda()  {    $proc = function() {      return $this-&gt;my_method();    };        return $proc();  }}$a = new A();echo $a-&gt;inner_lambda();</pre></div>
</div>
<br />Isso me resultou em: Fatal error: Using $this when not in object context<p />Mas de acordo com o RFC do PHP (link abaixo) o uso de $this deveria ser possível para funções lambda criadas dentro de objetos, isso deve ser corrigido nos próximos releases.<p /><a href="http://wiki.php.net/rfc/closures">RFC: closures</a><p /><h3>Conclusão</h3><br />O PHP está melhorando bastante, isso vai suprir muitas coisas para poder criar uma framework mais ágil e prática de se usar, espero melhoras até o release final do PHP 5.3, mas acho que o PHP está indo no caminho certo.<div class="blogger-post-footer"><img class="posterous_download_image" src="https://blogger.googleusercontent.com/tracker/1053117534982092858-5132500499503778176?l=wilker-dev.blogspot.com" height="1" alt="" width="1" /></div>
